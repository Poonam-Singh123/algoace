<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 3607: Power Grid Maintenance (C++)
    </title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 3607: Power Grid Maintenance (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given c power stations (1 to c) interconnected via n bidirectional cables. Stations form power grids. Initially all stations are online. Given queries: [1, x] - maintenance check for station x (if offline, resolved by smallest id online station in same grid, or -1 if none), [2, x] - station x goes offline. Return array of results for type [1, x] queries. Note: Offline nodes remain part of their grid structure.
            </p>
            <p><strong>Example:</strong>
                Input: c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]<br>
                Output: [3,2,3]<br>
                Explanation: Station 3 online (returns 3). Station 1 goes offline. Check station 1 (offline, returns 2). Station 2 goes offline. Check station 2 (offline, returns 3).
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; processQueries(int c, vector&lt;vector&lt;int&gt;&gt;&amp; connections, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {
        // Build adjacency list for the graph
        vector&lt;vector&lt;int&gt;&gt; graph(c + 1);
        for (const auto&amp; conn : connections) {
            graph[conn[0]].push_back(conn[1]);
            graph[conn[1]].push_back(conn[0]);
        }
        
        // Track online/offline status (initially all online)
        vector&lt;bool&gt; online(c + 1, true);
        
        // Find which grid (connected component) each station belongs to
        vector&lt;int&gt; grid(c + 1);
        int gridId = 0;
        
        function&lt;void(int, int)&gt; dfs = [&amp;](int node, int gid) {
            grid[node] = gid;
            for (int neighbor : graph[node]) {
                if (grid[neighbor] == 0) {
                    dfs(neighbor, gid);
                }
            }
        };
        
        // Assign grid IDs to all stations
        for (int i = 1; i &lt;= c; i++) {
            if (grid[i] == 0) {
                dfs(i, ++gridId);
            }
        }
        
        vector&lt;int&gt; result;
        
        for (const auto&amp; query : queries) {
            int type = query[0];
            int station = query[1];
            
            if (type == 1) {
                // Maintenance check
                if (online[station]) {
                    result.push_back(station);
                } else {
                    // Find smallest online station in same grid
                    int minOnline = -1;
                    for (int i = 1; i &lt;= c; i++) {
                        if (online[i] &amp;&amp; grid[i] == grid[station]) {
                            minOnline = i;
                            break;
                        }
                    }
                    result.push_back(minOnline);
                }
            } else {
                // Station goes offline
                online[station] = false;
            }
        }
        
        return result;
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>

</html>