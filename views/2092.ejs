<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2092. Find All People With Secret</title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>
<body>
    <main>
        <h1>LeetCode 2092: Find All People With Secret (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>] indicates that person x<sub>i</sub> and person y<sub>i</sub> have a meeting at time<sub>i</sub>. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson. Person 0 has a secret and initially shares the secret with person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person x<sub>i</sub> has the secret at time<sub>i</sub>, then they will share the secret with person y<sub>i</sub>, and vice versa. The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.
            </p>
            <p><strong>Example:</strong>
                Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1<br/>
                Output: [0,1,2,3,5]<br/>
                Explanation: At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5. Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.<br/><br/>
                Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3<br/>
                Output: [0,1,3]<br/>
                Explanation: At time 0, person 0 shares the secret with person 3. At time 2, person 1 does not have the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings.
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // Sort meetings by time
        sort(meetings.begin(), meetings.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
            return a[2] &lt; b[2];
        });
        
        // Track who knows the secret
        vector&lt;bool&gt; knowsSecret(n, false);
        knowsSecret[0] = true;
        knowsSecret[firstPerson] = true;
        
        int i = 0;
        while (i &lt; meetings.size()) {
            int currentTime = meetings[i][2];
            
            // Build graph for all meetings at current time
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            unordered_set&lt;int&gt; people;
            
            while (i &lt; meetings.size() &amp;&amp; meetings[i][2] == currentTime) {
                int x = meetings[i][0];
                int y = meetings[i][1];
                graph[x].push_back(y);
                graph[y].push_back(x);
                people.insert(x);
                people.insert(y);
                i++;
            }
            
            // BFS to spread secret among people at this time
            queue&lt;int&gt; q;
            for (int person : people) {
                if (knowsSecret[person]) {
                    q.push(person);
                }
            }
            
            while (!q.empty()) {
                int curr = q.front();
                q.pop();
                
                for (int neighbor : graph[curr]) {
                    if (!knowsSecret[neighbor]) {
                        knowsSecret[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
        
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (knowsSecret[i]) {
                result.push_back(i);
            }
        }
        
        return result;
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>
</html>