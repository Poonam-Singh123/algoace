<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 2598: Smallest Missing Non-negative Integer After Operations (C++)
    </title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 2598: Smallest Missing Non-negative Integer After Operations (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given a 0-indexed integer array nums and an integer value. In one operation, you can add or subtract value from any element of nums. The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it. For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2. Return the maximum MEX of nums after applying the mentioned operation any number of times.
            </p>
            <p><strong>Example:</strong>
                Input: nums = [1,-10,7,13,6,8], value = 5<br>
                Output: 4<br>
                Explanation: Add value to nums[1] twice to make nums = [1,0,7,13,6,8]. Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]. Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]. The MEX is 4.
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    int findSmallestInteger(vector&lt;int&gt;&amp; nums, int value) {
        // Count frequency of each remainder when divided by value
        vector&lt;int&gt; cnt(value, 0);
        
        for (int x : nums) {
            // Calculate remainder, handling negative numbers correctly
            int remainder = ((x % value) + value) % value;
            cnt[remainder]++;
        }
        
        // Find the smallest missing non-negative integer
        // Start from 0 and check each number
        for (int i = 0; ; i++) {
            // Check if we can form number i
            // Number i needs a number with remainder (i % value)
            if (cnt[i % value] == 0) {
                // No number available with this remainder
                return i;
            }
            // Use one number with this remainder
            cnt[i % value]--;
        }
        
        return 0; // Should never reach here
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>

</html>