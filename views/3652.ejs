<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3652. Minimum Cost to Equalize Array</title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>
<body>
    <main>
        <h1>LeetCode 3652: Minimum Cost to Equalize Array (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an integer array nums and two integers cost1 and cost2. You are allowed to perform either of the following operations any number of times: Choose an index i and increase nums[i] by 1 for a cost of cost1. Choose two different indices i and j and increase both nums[i] and nums[j] by 1 for a cost of cost2. Return the minimum cost required to make all elements in the array equal.
            </p>
            <p><strong>Example:</strong>
                Input: nums = [4,1], cost1 = 5, cost2 = 2<br/>
                Output: 15<br/>
                Explanation: We can make all elements equal to 4 with: Use operation 1 on nums[1] three times, cost = 3 * 5 = 15.<br/><br/>
                Input: nums = [2,3,3,3,5], cost1 = 2, cost2 = 1<br/>
                Output: 6<br/>
                Explanation: We can make all elements equal to 5.<br/><br/>
                Input: nums = [3,5,3], cost1 = 1, cost2 = 3<br/>
                Output: 4<br/>
                Explanation: Increase nums[0] and nums[2] to 5.
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    long long minCostToEqualizeArray(vector&lt;int&gt;&amp; nums, int cost1, int cost2) {
        const long long MOD = 1e9 + 7;
        int n = nums.size();
        
        if (n == 1) return 0;
        
        int maxVal = *max_element(nums.begin(), nums.end());
        long long minCost = LLONG_MAX;
        
        // Try making all elements equal to values from maxVal to maxVal + some buffer
        for (int target = maxVal; target &lt;= maxVal + n; target++) {
            long long totalOps = 0;
            long long maxDiff = 0;
            
            for (int num : nums) {
                long long diff = target - num;
                totalOps += diff;
                maxDiff = max(maxDiff, diff);
            }
            
            long long cost = 0;
            
            if (2 * cost1 &lt;= cost2 || n == 1) {
                // Always use operation 1
                cost = totalOps * cost1;
            } else {
                // Try to use operation 2 as much as possible
                long long remaining = totalOps - maxDiff;
                
                if (maxDiff &gt; remaining) {
                    // Need to use operation 1 for the difference
                    long long diff = maxDiff - remaining;
                    cost = diff * cost1 + remaining * cost2;
                } else {
                    // Can balance using operation 2
                    if (totalOps % 2 == 0) {
                        cost = (totalOps / 2) * cost2;
                    } else {
                        cost = (totalOps / 2) * cost2 + cost1;
                    }
                }
            }
            
            minCost = min(minCost, cost);
        }
        
        return minCost % MOD;
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>
</html>