<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2977. Minimum Cost to Convert String II</title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>
<body>
    <main>
        <h1>LeetCode 2977: Minimum Cost to Convert String II (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i]. You start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any index in source can be part of at most one operation. Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.
            </p>
            <p><strong>Example:</strong>
                Input: source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]<br/>
                Output: 28<br/>
                Explanation: Convert "abcd" to "acbe" by transforming substrings optimally.<br/><br/>
                Input: source = "abcdefgh", target = "acdeeghh", original = ["bcd","fgh","thh"], changed = ["cde","thh","ghh"], cost = [1,3,5]<br/>
                Output: 9<br/>
                Explanation: Transform "bcd" to "cde" with cost 1, and "fgh" to "thh" to "ghh" with total cost 3 + 5 = 8. Total = 9.<br/><br/>
                Input: source = "abcdefgh", target = "addddddd", original = ["bcd","defgh"], changed = ["ddd","ddddd"], cost = [100,1578]<br/>
                Output: -1<br/>
                Explanation: It is impossible to convert source to target.
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    long long minimumCost(string source, string target, vector&lt;string&gt;&amp; original, 
                          vector&lt;string&gt;&amp; changed, vector&lt;int&gt;&amp; cost) {
        int n = source.length();
        int m = original.size();
        
        // Build string to index mapping
        unordered_map&lt;string, int&gt; strToIdx;
        int idx = 0;
        for (const string&amp; s : original) {
            if (strToIdx.find(s) == strToIdx.end()) {
                strToIdx[s] = idx++;
            }
        }
        for (const string&amp; s : changed) {
            if (strToIdx.find(s) == strToIdx.end()) {
                strToIdx[s] = idx++;
            }
        }
        
        // Floyd-Warshall for minimum cost transformations
        const long long INF = 1e18;
        vector&lt;vector&lt;long long&gt;&gt; dist(idx, vector&lt;long long&gt;(idx, INF));
        for (int i = 0; i &lt; idx; i++) {
            dist[i][i] = 0;
        }
        
        for (int i = 0; i &lt; m; i++) {
            int from = strToIdx[original[i]];
            int to = strToIdx[changed[i]];
            dist[from][to] = min(dist[from][to], (long long)cost[i]);
        }
        
        for (int k = 0; k &lt; idx; k++) {
            for (int i = 0; i &lt; idx; i++) {
                for (int j = 0; j &lt; idx; j++) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
        
        // DP: dp[i] = minimum cost to convert source[0..i-1] to target[0..i-1]
        vector&lt;long long&gt; dp(n + 1, INF);
        dp[0] = 0;
        
        for (int i = 0; i &lt; n; i++) {
            if (dp[i] == INF) continue;
            
            // Try no transformation (characters must match)
            if (source[i] == target[i]) {
                dp[i + 1] = min(dp[i + 1], dp[i]);
            }
            
            // Try all possible substring transformations
            for (int len = 1; i + len &lt;= n; len++) {
                string srcSub = source.substr(i, len);
                string tgtSub = target.substr(i, len);
                
                if (srcSub == tgtSub) {
                    dp[i + len] = min(dp[i + len], dp[i]);
                } else if (strToIdx.count(srcSub) &amp;&amp; strToIdx.count(tgtSub)) {
                    int from = strToIdx[srcSub];
                    int to = strToIdx[tgtSub];
                    if (dist[from][to] &lt; INF) {
                        dp[i + len] = min(dp[i + len], dp[i] + dist[from][to]);
                    }
                }
            }
        }
        
        return dp[n] == INF ? -1 : dp[n];
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>
</html>