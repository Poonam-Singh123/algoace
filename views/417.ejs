<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 417: Pacific Atlantic Water Flow (C++)
    </title>
    <link rel="stylesheet" href="/styles.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 417: Pacific Atlantic Water Flow (C++)</h1>

        <div class="problem-description">
            <p><strong>Problem:</strong>
                There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). Water can flow from a cell to an adjacent cell (up, down, left, right) if the adjacent cell's height is less than or equal to the current cell's height. Find all cells where water can flow to both the Pacific and Atlantic oceans.
            </p>
            <p><strong>Example:</strong>
                Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]<br>
                Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]<br>
                Explanation: These cells can reach both Pacific (top/left) and Atlantic (bottom/right) oceans.
            </p>
        </div>

        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {
        if (heights.empty() || heights[0].empty()) {
            return {};
        }
        
        int m = heights.size();
        int n = heights[0].size();
        
        // Track cells that can reach Pacific and Atlantic
        vector&lt;vector&lt;bool&gt;&gt; pacific(m, vector&lt;bool&gt;(n, false));
        vector&lt;vector&lt;bool&gt;&gt; atlantic(m, vector&lt;bool&gt;(n, false));
        
        // DFS from Pacific borders (top and left edges)
        for (int i = 0; i &lt; m; i++) {
            dfs(heights, pacific, i, 0, m, n);
        }
        for (int j = 0; j &lt; n; j++) {
            dfs(heights, pacific, 0, j, m, n);
        }
        
        // DFS from Atlantic borders (bottom and right edges)
        for (int i = 0; i &lt; m; i++) {
            dfs(heights, atlantic, i, n - 1, m, n);
        }
        for (int j = 0; j &lt; n; j++) {
            dfs(heights, atlantic, m - 1, j, m, n);
        }
        
        // Find cells that can reach both oceans
        vector&lt;vector&lt;int&gt;&gt; result;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (pacific[i][j] &amp;&amp; atlantic[i][j]) {
                    result.push_back({i, j});
                }
            }
        }
        
        return result;
    }
    
private:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; heights, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, 
             int row, int col, int m, int n) {
        // Mark current cell as visited
        visited[row][col] = true;
        
        // Directions: up, down, left, right
        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        
        // Explore all 4 directions
        for (int i = 0; i &lt; 4; i++) {
            int newRow = row + dirs[i][0];
            int newCol = col + dirs[i][1];
            
            // Skip if out of bounds or already visited
            if (newRow &lt; 0 || newRow &gt;= m || newCol &lt; 0 || newCol &gt;= n || visited[newRow][newCol]) {
                continue;
            }
            
            // Water can flow from neighbor to current cell if neighbor is higher or equal
            // (We're doing reverse flow: from ocean upward)
            if (heights[newRow][newCol] &gt;= heights[row][col]) {
                dfs(heights, visited, newRow, newCol, m, n);
            }
        }
    }
};</code></pre>
        </div>

        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>

</html>